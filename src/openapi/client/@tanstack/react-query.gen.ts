// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { authenticate, clearAllMentions, clearChatMessage, collectionSearch, convertCapsuleToFolder, convertFolderToCapsule, copyManyItems, createApp, createAppAction, createAppData, createAppDataFile, createAppSetting, createAppSettingFile, createBookmark, createCapsule, createChatbotCompletionPrompt, createChatMessage, createDocument, createEtherpad, createFolder, createFolderWithThumbnail, createInvitation, createItem, createItemFlag, createItemLike, createItemMembership, createItemWithThumbnail, createLink, createMembershipRequest, createOwnProfile, createPage, createPassword, createShortcut, createShortLink, createTagForItem, createVisibility, deleteAlias, deleteApiItemsByIdThumbnails, deleteApiMembersMembersByIdDelete, deleteAppData, deleteAppSetting, deleteBookmark, deleteChatMessage, deleteCurrentAccount, deleteGeolocation, deleteInvitation, deleteItemLike, deleteItemLoginSchema, deleteItemMembership, deleteManyItems, deleteMembershipRequest, deleteMention, deleteTagForItem, deleteVisibility, downloadAppDataFile, downloadAppSettingFile, downloadAvatar, downloadFile, downloadItemThumbnail, enroll, exportActions, exportMemberData, exportZip, generateAppToken, geolocationReverse, geolocationSearch, getAccessibleItems, getApiItemsCollectionsSearchRebuild, getApiItemsH5pAssetsIntegrationHtml, getApiItemsPublicationByItemIdStatus, getApiStatus, getApiVersion, getApiWs, getAppActionsForApp, getAppContext, getAppDataForApp, getAppList, getAppSettingsForApp, getChat, getChildren, getCollectionInformations, getCollectionsForMember, getCountForTags, getCurrentAccount, getCurrentSettings, getDescendantItems, getEtherpadFromItem, getFacetsForName, getFeaturedCollections, getFlagTypes, getGeolocationByItem, getInvitationById, getInvitationForItem, getItem, getItemActionsByDay, getItemActionsByHour, getItemActionsByWeekday, getItemLoginSchema, getItemLoginSchemaType, getItemMembershipsForItem, getItemsInBox, getLatestItemValidationGroup, getLikesForCurrentMember, getLikesForItem, getLinkMetadata, getMemberProfile, getMembersActions, getMembershipRequestsByItemId, getMostLikedCollections, getMostRecentCollections, getNextMaintenance, getOneMember, getOwnBookmark, getOwnMembershipRequestByItemId, getOwnMentions, getOwnMostUsedApps, getOwnPasswordStatus, getOwnProfile, getOwnRecycledItems, getParentItems, getShortLinkAvailability, getShortLinkRedirection, getShortLinksForItem, getStorage, getStorageFiles, getTagsForItem, getUrl, graaspZipExport, health, importH5P, importZip, inviteFromCsv, inviteFromCsvWithTemplate, login, loginOrRegisterAsGuest, marketingEmailsSubscribe, marketingEmailsUnsubscribe, moveManyItems, type Options, pagesWebsockets, pagesWebsockets2, patchChangeEmail, patchChatMessage, patchMention, postAction, postApiItemsByIdThumbnails, postApiMembersAvatar, postChangeEmail, publishItem, putGeolocation, recycleManyItems, register, reorderItem, requestPasswordResetLink, resetPassword, restoreManyItems, sendInvitation, signInWithPassword, signOut, unpublishItem, updateApp, updateAppData, updateAppSetting, updateCurrentAccount, updateDocument, updateEtherpad, updateFile, updateFolder, updateInvitation, updateItem, updateItemLoginSchema, updateItemMembership, updateLink, updateOwnProfile, updatePassword, updateShortcut, updateShortLink, uploadFile, validateItem } from '../sdk.gen';
import type { AuthenticateData, ClearAllMentionsData, ClearAllMentionsError, ClearAllMentionsResponse, ClearChatMessageData, ClearChatMessageError, ClearChatMessageResponse, CollectionSearchData, CollectionSearchError, CollectionSearchResponse, ConvertCapsuleToFolderData, ConvertCapsuleToFolderError, ConvertCapsuleToFolderResponse, ConvertFolderToCapsuleData, ConvertFolderToCapsuleError, ConvertFolderToCapsuleResponse, CopyManyItemsData, CopyManyItemsError, CopyManyItemsResponse, CreateAppActionData, CreateAppActionError, CreateAppActionResponse, CreateAppData, CreateAppDataData, CreateAppDataError, CreateAppDataFileData, CreateAppDataFileError, CreateAppDataFileResponse, CreateAppDataResponse, CreateAppError, CreateAppResponse, CreateAppSettingData, CreateAppSettingError, CreateAppSettingFileData, CreateAppSettingFileError, CreateAppSettingFileResponse, CreateAppSettingResponse, CreateBookmarkData, CreateBookmarkError, CreateBookmarkResponse, CreateCapsuleData, CreateCapsuleError, CreateCapsuleResponse, CreateChatbotCompletionPromptData, CreateChatbotCompletionPromptError, CreateChatbotCompletionPromptResponse, CreateChatMessageData, CreateChatMessageError, CreateChatMessageResponse, CreateDocumentData, CreateDocumentError, CreateDocumentResponse, CreateEtherpadData, CreateEtherpadError, CreateEtherpadResponse, CreateFolderData, CreateFolderError, CreateFolderResponse, CreateFolderWithThumbnailData, CreateFolderWithThumbnailError, CreateFolderWithThumbnailResponse, CreateInvitationData, CreateInvitationError, CreateInvitationResponse, CreateItemData, CreateItemError, CreateItemFlagData, CreateItemFlagError, CreateItemFlagResponse, CreateItemLikeData, CreateItemLikeError, CreateItemLikeResponse, CreateItemMembershipData, CreateItemMembershipError, CreateItemMembershipResponse, CreateItemResponse, CreateItemWithThumbnailData, CreateItemWithThumbnailError, CreateItemWithThumbnailResponse, CreateLinkData, CreateLinkError, CreateLinkResponse, CreateMembershipRequestData, CreateMembershipRequestResponse, CreateOwnProfileData, CreateOwnProfileError, CreateOwnProfileResponse, CreatePageData, CreatePageError, CreatePageResponse, CreatePasswordData, CreatePasswordError, CreatePasswordResponse, CreateShortcutData, CreateShortcutError, CreateShortcutResponse, CreateShortLinkData, CreateShortLinkError, CreateShortLinkResponse, CreateTagForItemData, CreateTagForItemError, CreateTagForItemResponse, CreateVisibilityData, CreateVisibilityError, CreateVisibilityResponse, DeleteAliasData, DeleteAliasError, DeleteAliasResponse, DeleteApiItemsByIdThumbnailsData, DeleteApiMembersMembersByIdDeleteData, DeleteAppDataData, DeleteAppDataError, DeleteAppDataResponse, DeleteAppSettingData, DeleteAppSettingError, DeleteAppSettingResponse, DeleteBookmarkData, DeleteBookmarkError, DeleteBookmarkResponse, DeleteChatMessageData, DeleteChatMessageError, DeleteChatMessageResponse, DeleteCurrentAccountData, DeleteCurrentAccountError, DeleteCurrentAccountResponse, DeleteGeolocationData, DeleteGeolocationError, DeleteGeolocationResponse, DeleteInvitationData, DeleteInvitationError, DeleteInvitationResponse, DeleteItemLikeData, DeleteItemLikeError, DeleteItemLikeResponse, DeleteItemLoginSchemaData, DeleteItemLoginSchemaError, DeleteItemMembershipData, DeleteItemMembershipError, DeleteItemMembershipResponse, DeleteManyItemsData, DeleteManyItemsError, DeleteManyItemsResponse, DeleteMembershipRequestData, DeleteMembershipRequestResponse, DeleteMentionData, DeleteMentionError, DeleteMentionResponse, DeleteTagForItemData, DeleteTagForItemError, DeleteTagForItemResponse, DeleteVisibilityData, DeleteVisibilityError, DeleteVisibilityResponse, DownloadAppDataFileData, DownloadAppSettingFileData, DownloadAvatarData, DownloadFileData, DownloadFileError, DownloadItemThumbnailData, EnrollData, EnrollResponse, ExportActionsData, ExportActionsError, ExportActionsResponse, ExportMemberDataData, ExportMemberDataError, ExportMemberDataResponse, ExportZipData, ExportZipError, GenerateAppTokenData, GenerateAppTokenError, GenerateAppTokenResponse, GeolocationReverseData, GeolocationSearchData, GetAccessibleItemsData, GetAccessibleItemsError, GetAccessibleItemsResponse, GetApiItemsCollectionsSearchRebuildData, GetApiItemsH5pAssetsIntegrationHtmlData, GetApiItemsPublicationByItemIdStatusData, GetApiStatusData, GetApiVersionData, GetApiWsData, GetAppActionsForAppData, GetAppContextData, GetAppDataForAppData, GetAppListData, GetAppSettingsForAppData, GetChatData, GetChildrenData, GetCollectionInformationsData, GetCollectionsForMemberData, GetCountForTagsData, GetCurrentAccountData, GetCurrentSettingsData, GetDescendantItemsData, GetEtherpadFromItemData, GetFacetsForNameData, GetFacetsForNameError, GetFacetsForNameResponse, GetFeaturedCollectionsData, GetFlagTypesData, GetGeolocationByItemData, GetInvitationByIdData, GetInvitationForItemData, GetItemActionsByDayData, GetItemActionsByHourData, GetItemActionsByWeekdayData, GetItemData, GetItemLoginSchemaData, GetItemLoginSchemaTypeData, GetItemMembershipsForItemData, GetItemsInBoxData, GetLatestItemValidationGroupData, GetLikesForCurrentMemberData, GetLikesForItemData, GetLinkMetadataData, GetMemberProfileData, GetMembersActionsData, GetMembershipRequestsByItemIdData, GetMostLikedCollectionsData, GetMostRecentCollectionsData, GetNextMaintenanceData, GetOneMemberData, GetOwnBookmarkData, GetOwnMembershipRequestByItemIdData, GetOwnMentionsData, GetOwnMostUsedAppsData, GetOwnPasswordStatusData, GetOwnProfileData, GetOwnRecycledItemsData, GetOwnRecycledItemsError, GetOwnRecycledItemsResponse, GetParentItemsData, GetShortLinkAvailabilityData, GetShortLinkRedirectionData, GetShortLinksForItemData, GetStorageData, GetStorageFilesData, GetStorageFilesError, GetStorageFilesResponse, GetTagsForItemData, GetUrlData, GraaspZipExportData, GraaspZipExportError, HealthData, ImportH5pData, ImportH5pError, ImportH5pResponse, ImportZipData, ImportZipError, InviteFromCsvData, InviteFromCsvError, InviteFromCsvResponse, InviteFromCsvWithTemplateData, InviteFromCsvWithTemplateError, InviteFromCsvWithTemplateResponse, LoginData, LoginError, LoginOrRegisterAsGuestData, LoginOrRegisterAsGuestError, LoginOrRegisterAsGuestResponse, LoginResponse, MarketingEmailsSubscribeData, MarketingEmailsSubscribeError, MarketingEmailsSubscribeResponse, MarketingEmailsUnsubscribeData, MarketingEmailsUnsubscribeError, MarketingEmailsUnsubscribeResponse, MoveManyItemsData, MoveManyItemsError, MoveManyItemsResponse, PagesWebsockets2Data, PagesWebsocketsData, PatchChangeEmailData, PatchChangeEmailError, PatchChangeEmailResponse, PatchChatMessageData, PatchChatMessageError, PatchChatMessageResponse, PatchMentionData, PatchMentionError, PatchMentionResponse, PostActionData, PostActionError, PostActionResponse, PostApiItemsByIdThumbnailsData, PostApiItemsByIdThumbnailsError, PostApiItemsByIdThumbnailsResponse, PostApiMembersAvatarData, PostApiMembersAvatarResponse, PostChangeEmailData, PostChangeEmailError, PostChangeEmailResponse, PublishItemData, PublishItemError, PublishItemResponse, PutGeolocationData, PutGeolocationError, PutGeolocationResponse, RecycleManyItemsData, RecycleManyItemsError, RecycleManyItemsResponse, RegisterData, RegisterError, RegisterResponse, ReorderItemData, ReorderItemError, ReorderItemResponse, RequestPasswordResetLinkData, ResetPasswordData, RestoreManyItemsData, RestoreManyItemsError, RestoreManyItemsResponse, SendInvitationData, SendInvitationError, SendInvitationResponse, SignInWithPasswordData, SignInWithPasswordError, SignInWithPasswordResponse, SignOutData, SignOutError, SignOutResponse, UnpublishItemData, UnpublishItemError, UnpublishItemResponse, UpdateAppData, UpdateAppDataData, UpdateAppDataError, UpdateAppDataResponse, UpdateAppError, UpdateAppResponse, UpdateAppSettingData, UpdateAppSettingError, UpdateAppSettingResponse, UpdateCurrentAccountData, UpdateCurrentAccountError, UpdateDocumentData, UpdateDocumentError, UpdateDocumentResponse, UpdateEtherpadData, UpdateEtherpadError, UpdateEtherpadResponse, UpdateFileData, UpdateFileError, UpdateFolderData, UpdateFolderError, UpdateFolderResponse, UpdateInvitationData, UpdateInvitationError, UpdateInvitationResponse, UpdateItemData, UpdateItemError, UpdateItemLoginSchemaData, UpdateItemLoginSchemaError, UpdateItemMembershipData, UpdateItemMembershipError, UpdateItemMembershipResponse, UpdateItemResponse, UpdateLinkData, UpdateLinkError, UpdateLinkResponse, UpdateOwnProfileData, UpdateOwnProfileError, UpdateOwnProfileResponse, UpdatePasswordData, UpdatePasswordError, UpdatePasswordResponse, UpdateShortcutData, UpdateShortcutError, UpdateShortcutResponse, UpdateShortLinkData, UpdateShortLinkError, UpdateShortLinkResponse, UploadFileData, UploadFileError, UploadFileResponse, ValidateItemData, ValidateItemError, ValidateItemResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const healthQueryKey = (options?: Options<HealthData>) => createQueryKey('health', options);

/**
 * Health check endpoint
 * Return a simple 200: OK when the server is running
 */
export const healthOptions = (options?: Options<HealthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await health({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: healthQueryKey(options)
    });
};

export const getApiStatusQueryKey = (options?: Options<GetApiStatusData>) => createQueryKey('getApiStatus', options);

export const getApiStatusOptions = (options?: Options<GetApiStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiStatusQueryKey(options)
    });
};

export const getApiVersionQueryKey = (options?: Options<GetApiVersionData>) => createQueryKey('getApiVersion', options);

export const getApiVersionOptions = (options?: Options<GetApiVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiVersionQueryKey(options)
    });
};

/**
 * Register with email and name
 * Register with email and name, protected by a captcha. The captcha is used to prevent brute force attacks.
 */
export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await register({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Login with email
 * Login with email, protected by a captcha. The captcha is used to prevent brute force attacks.
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await login({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authenticateQueryKey = (options: Options<AuthenticateData>) => createQueryKey('authenticate', options);

/**
 * Authentication validating the token
 * Authenticate to obtain session cookie given provided token and verifier
 */
export const authenticateOptions = (options: Options<AuthenticateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authenticate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authenticateQueryKey(options)
    });
};

/**
 * Log out
 * Log out from current session
 */
export const signOutMutation = (options?: Partial<Options<SignOutData>>): UseMutationOptions<SignOutResponse, SignOutError, Options<SignOutData>> => {
    const mutationOptions: UseMutationOptions<SignOutResponse, SignOutError, Options<SignOutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await signOut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Log in with email and password
 * Log in with email and password. The user must provide a valid email, password, and captcha. The captcha is used to prevent brute force attacks.
 */
export const signInWithPasswordMutation = (options?: Partial<Options<SignInWithPasswordData>>): UseMutationOptions<SignInWithPasswordResponse, SignInWithPasswordError, Options<SignInWithPasswordData>> => {
    const mutationOptions: UseMutationOptions<SignInWithPasswordResponse, SignInWithPasswordError, Options<SignInWithPasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await signInWithPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update the password of the authenticated member
 * Update the password of the authenticated member. The user must provide the current password and the new password.
 */
export const updatePasswordMutation = (options?: Partial<Options<UpdatePasswordData>>): UseMutationOptions<UpdatePasswordResponse, UpdatePasswordError, Options<UpdatePasswordData>> => {
    const mutationOptions: UseMutationOptions<UpdatePasswordResponse, UpdatePasswordError, Options<UpdatePasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Set a password for the authenticated member
 * Set a password for the authenticated member. This is only possible if the member does not have a password set already.
 */
export const createPasswordMutation = (options?: Partial<Options<CreatePasswordData>>): UseMutationOptions<CreatePasswordResponse, CreatePasswordError, Options<CreatePasswordData>> => {
    const mutationOptions: UseMutationOptions<CreatePasswordResponse, CreatePasswordError, Options<CreatePasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm the reset password request
 * Confirm the reset password request. This will change the password of the member associated with the reset password request.
 */
export const resetPasswordMutation = (options?: Partial<Options<ResetPasswordData>>): UseMutationOptions<unknown, DefaultError, Options<ResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResetPasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resetPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a reset password request
 * Create a reset password request. This will send an email to the member in his language with a link to reset the password. The link will be valid for a limited time.
 */
export const requestPasswordResetLinkMutation = (options?: Partial<Options<RequestPasswordResetLinkData>>): UseMutationOptions<unknown, DefaultError, Options<RequestPasswordResetLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RequestPasswordResetLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestPasswordResetLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOwnPasswordStatusQueryKey = (options?: Options<GetOwnPasswordStatusData>) => createQueryKey('getOwnPasswordStatus', options);

/**
 * Get the current password status of the authenticated member
 * Return whether the authenticated member has a password defined.
 */
export const getOwnPasswordStatusOptions = (options?: Options<GetOwnPasswordStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnPasswordStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnPasswordStatusQueryKey(options)
    });
};

export const getApiWsQueryKey = (options?: Options<GetApiWsData>) => createQueryKey('getApiWs', options);

export const getApiWsOptions = (options?: Options<GetApiWsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiWs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiWsQueryKey(options)
    });
};

export const getMembersActionsQueryKey = (options?: Options<GetMembersActionsData>) => createQueryKey('getMembersActions', options);

export const getMembersActionsOptions = (options?: Options<GetMembersActionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembersActions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersActionsQueryKey(options)
    });
};

export const deleteApiMembersMembersByIdDeleteMutation = (options?: Partial<Options<DeleteApiMembersMembersByIdDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteApiMembersMembersByIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteApiMembersMembersByIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiMembersMembersByIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete authenticated account
 * Delete authenticated account. This action is irreversible!
 */
export const deleteCurrentAccountMutation = (options?: Partial<Options<DeleteCurrentAccountData>>): UseMutationOptions<DeleteCurrentAccountResponse, DeleteCurrentAccountError, Options<DeleteCurrentAccountData>> => {
    const mutationOptions: UseMutationOptions<DeleteCurrentAccountResponse, DeleteCurrentAccountError, Options<DeleteCurrentAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCurrentAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentAccountQueryKey = (options?: Options<GetCurrentAccountData>) => createQueryKey('getCurrentAccount', options);

/**
 * Get information of current authenticated account
 * Get information of current authenticated account, that can be a member or a guest.
 */
export const getCurrentAccountOptions = (options?: Options<GetCurrentAccountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentAccount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentAccountQueryKey(options)
    });
};

/**
 * Update authenticated account
 * Update authenticated account, such as name or language.
 */
export const updateCurrentAccountMutation = (options?: Partial<Options<UpdateCurrentAccountData>>): UseMutationOptions<unknown, UpdateCurrentAccountError, Options<UpdateCurrentAccountData>> => {
    const mutationOptions: UseMutationOptions<unknown, UpdateCurrentAccountError, Options<UpdateCurrentAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCurrentAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStorageQueryKey = (options?: Options<GetStorageData>) => createQueryKey('getStorage', options);

/**
 * Get storage values
 * Get amount of storage used for current member, and its maximum storage value.
 */
export const getStorageOptions = (options?: Options<GetStorageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStorage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStorageQueryKey(options)
    });
};

export const getStorageFilesQueryKey = (options: Options<GetStorageFilesData>) => createQueryKey('getStorageFiles', options);

/**
 * Get storage files data
 * Get files data counted in storage of current member.
 */
export const getStorageFilesOptions = (options: Options<GetStorageFilesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStorageFiles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStorageFilesQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getStorageFilesInfiniteQueryKey = (options: Options<GetStorageFilesData>): QueryKey<Options<GetStorageFilesData>> => createQueryKey('getStorageFiles', options, true);

/**
 * Get storage files data
 * Get files data counted in storage of current member.
 */
export const getStorageFilesInfiniteOptions = (options: Options<GetStorageFilesData>) => {
    return infiniteQueryOptions<GetStorageFilesResponse, GetStorageFilesError, InfiniteData<GetStorageFilesResponse>, QueryKey<Options<GetStorageFilesData>>, number | Pick<QueryKey<Options<GetStorageFilesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetStorageFilesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getStorageFiles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStorageFilesInfiniteQueryKey(options)
    });
};

export const getOneMemberQueryKey = (options: Options<GetOneMemberData>) => createQueryKey('getOneMember', options);

/**
 * Get member by id
 * Get member by id.
 */
export const getOneMemberOptions = (options: Options<GetOneMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOneMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOneMemberQueryKey(options)
    });
};

/**
 * Change email
 * Change email for current authenticated member.
 */
export const patchChangeEmailMutation = (options?: Partial<Options<PatchChangeEmailData>>): UseMutationOptions<PatchChangeEmailResponse, PatchChangeEmailError, Options<PatchChangeEmailData>> => {
    const mutationOptions: UseMutationOptions<PatchChangeEmailResponse, PatchChangeEmailError, Options<PatchChangeEmailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchChangeEmail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Request to change email
 * Request to change email for current authenticated member.
 */
export const postChangeEmailMutation = (options?: Partial<Options<PostChangeEmailData>>): UseMutationOptions<PostChangeEmailResponse, PostChangeEmailError, Options<PostChangeEmailData>> => {
    const mutationOptions: UseMutationOptions<PostChangeEmailResponse, PostChangeEmailError, Options<PostChangeEmailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postChangeEmail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Subscribe to marketing emails
 * Subscribe to marketing emails for current authenticated member.
 */
export const marketingEmailsSubscribeMutation = (options?: Partial<Options<MarketingEmailsSubscribeData>>): UseMutationOptions<MarketingEmailsSubscribeResponse, MarketingEmailsSubscribeError, Options<MarketingEmailsSubscribeData>> => {
    const mutationOptions: UseMutationOptions<MarketingEmailsSubscribeResponse, MarketingEmailsSubscribeError, Options<MarketingEmailsSubscribeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await marketingEmailsSubscribe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unsubscribe from marketing emails
 * Unsubscribe from marketing emails for current authenticated member.
 */
export const marketingEmailsUnsubscribeMutation = (options?: Partial<Options<MarketingEmailsUnsubscribeData>>): UseMutationOptions<MarketingEmailsUnsubscribeResponse, MarketingEmailsUnsubscribeError, Options<MarketingEmailsUnsubscribeData>> => {
    const mutationOptions: UseMutationOptions<MarketingEmailsUnsubscribeResponse, MarketingEmailsUnsubscribeError, Options<MarketingEmailsUnsubscribeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await marketingEmailsUnsubscribe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentSettingsQueryKey = (options?: Options<GetCurrentSettingsData>) => createQueryKey('getCurrentSettings', options);

/**
 * Get the settings of the authenticated member
 * Return the settings of the authenticated member.
 */
export const getCurrentSettingsOptions = (options?: Options<GetCurrentSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentSettingsQueryKey(options)
    });
};

export const postApiMembersAvatarMutation = (options?: Partial<Options<PostApiMembersAvatarData>>): UseMutationOptions<PostApiMembersAvatarResponse, DefaultError, Options<PostApiMembersAvatarData>> => {
    const mutationOptions: UseMutationOptions<PostApiMembersAvatarResponse, DefaultError, Options<PostApiMembersAvatarData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiMembersAvatar({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadAvatarQueryKey = (options: Options<DownloadAvatarData>) => createQueryKey('downloadAvatar', options);

/**
 * Get a member's avatar
 * Get a member's avatar at given size. The return value is empty if the member did not previously uploaded an avatar. Since guests don't have avatars, the return value will also be empty.
 */
export const downloadAvatarOptions = (options: Options<DownloadAvatarData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadAvatar({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadAvatarQueryKey(options)
    });
};

export const getOwnProfileQueryKey = (options?: Options<GetOwnProfileData>) => createQueryKey('getOwnProfile', options);

/**
 * Get profile of current member
 * Get profile of current member
 */
export const getOwnProfileOptions = (options?: Options<GetOwnProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnProfileQueryKey(options)
    });
};

export const getMemberProfileQueryKey = (options: Options<GetMemberProfileData>) => createQueryKey('getMemberProfile', options);

/**
 * Get profile of given member
 * Get profile of given member
 */
export const getMemberProfileOptions = (options: Options<GetMemberProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMemberProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMemberProfileQueryKey(options)
    });
};

/**
 * Update profile of current member
 * Update profile of current member
 */
export const updateOwnProfileMutation = (options?: Partial<Options<UpdateOwnProfileData>>): UseMutationOptions<UpdateOwnProfileResponse, UpdateOwnProfileError, Options<UpdateOwnProfileData>> => {
    const mutationOptions: UseMutationOptions<UpdateOwnProfileResponse, UpdateOwnProfileError, Options<UpdateOwnProfileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateOwnProfile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create profile for current member
 * Create profile for current member.
 */
export const createOwnProfileMutation = (options?: Partial<Options<CreateOwnProfileData>>): UseMutationOptions<CreateOwnProfileResponse, CreateOwnProfileError, Options<CreateOwnProfileData>> => {
    const mutationOptions: UseMutationOptions<CreateOwnProfileResponse, CreateOwnProfileError, Options<CreateOwnProfileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createOwnProfile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Request all related data of authenticated member
 * Request a download link to have access to all data related to the authenticated user. The link is valid for one week.
 */
export const exportMemberDataMutation = (options?: Partial<Options<ExportMemberDataData>>): UseMutationOptions<ExportMemberDataResponse, ExportMemberDataError, Options<ExportMemberDataData>> => {
    const mutationOptions: UseMutationOptions<ExportMemberDataResponse, ExportMemberDataError, Options<ExportMemberDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exportMemberData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAppListQueryKey = (options?: Options<GetAppListData>) => createQueryKey('getAppList', options);

/**
 * Get list of available apps
 * Get list of available apps
 */
export const getAppListOptions = (options?: Options<GetAppListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAppList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAppListQueryKey(options)
    });
};

export const getOwnMostUsedAppsQueryKey = (options?: Options<GetOwnMostUsedAppsData>) => createQueryKey('getOwnMostUsedApps', options);

/**
 * Get the user's most used apps
 * Get a list of the apps the user has used the most to ease the addition of new apps.
 */
export const getOwnMostUsedAppsOptions = (options?: Options<GetOwnMostUsedAppsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnMostUsedApps({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnMostUsedAppsQueryKey(options)
    });
};

/**
 * Generate auth token for an app
 * Generate auth token for an app to access app API
 */
export const generateAppTokenMutation = (options?: Partial<Options<GenerateAppTokenData>>): UseMutationOptions<GenerateAppTokenResponse, GenerateAppTokenError, Options<GenerateAppTokenData>> => {
    const mutationOptions: UseMutationOptions<GenerateAppTokenResponse, GenerateAppTokenError, Options<GenerateAppTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await generateAppToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAppContextQueryKey = (options: Options<GetAppContextData>) => createQueryKey('getAppContext', options);

/**
 * Get context information of an app
 * Get context information of an app
 */
export const getAppContextOptions = (options: Options<GetAppContextData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAppContext({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAppContextQueryKey(options)
    });
};

export const getAppDataForAppQueryKey = (options: Options<GetAppDataForAppData>) => createQueryKey('getAppDataForApp', options);

/**
 * Get all app data of an app
 * Get app data saved for an app, depending on the permission of the user and the data visibility.
 */
export const getAppDataForAppOptions = (options: Options<GetAppDataForAppData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAppDataForApp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAppDataForAppQueryKey(options)
    });
};

/**
 * Create a user data for an app
 * Create a user data in an app given data and type.
 */
export const createAppDataMutation = (options?: Partial<Options<CreateAppDataData>>): UseMutationOptions<CreateAppDataResponse, CreateAppDataError, Options<CreateAppDataData>> => {
    const mutationOptions: UseMutationOptions<CreateAppDataResponse, CreateAppDataError, Options<CreateAppDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAppData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an app data
 * Delete a given app data.
 */
export const deleteAppDataMutation = (options?: Partial<Options<DeleteAppDataData>>): UseMutationOptions<DeleteAppDataResponse, DeleteAppDataError, Options<DeleteAppDataData>> => {
    const mutationOptions: UseMutationOptions<DeleteAppDataResponse, DeleteAppDataError, Options<DeleteAppDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAppData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update an app data
 * Update a given app data with new data.
 */
export const updateAppDataMutation = (options?: Partial<Options<UpdateAppDataData>>): UseMutationOptions<UpdateAppDataResponse, UpdateAppDataError, Options<UpdateAppDataData>> => {
    const mutationOptions: UseMutationOptions<UpdateAppDataResponse, UpdateAppDataError, Options<UpdateAppDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAppData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create app data file
 * Upload a file to create a corresponding app data. The created app data will have a type file and visibility member. The data property will contain the file properties.
 */
export const createAppDataFileMutation = (options?: Partial<Options<CreateAppDataFileData>>): UseMutationOptions<CreateAppDataFileResponse, CreateAppDataFileError, Options<CreateAppDataFileData>> => {
    const mutationOptions: UseMutationOptions<CreateAppDataFileResponse, CreateAppDataFileError, Options<CreateAppDataFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAppDataFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadAppDataFileQueryKey = (options: Options<DownloadAppDataFileData>) => createQueryKey('downloadAppDataFile', options);

/**
 * Download app data file
 * Download app data file.
 */
export const downloadAppDataFileOptions = (options: Options<DownloadAppDataFileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadAppDataFile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadAppDataFileQueryKey(options)
    });
};

export const getAppActionsForAppQueryKey = (options: Options<GetAppActionsForAppData>) => createQueryKey('getAppActionsForApp', options);

/**
 * Get all actions of an app
 * Get all actions saved for an app.
 */
export const getAppActionsForAppOptions = (options: Options<GetAppActionsForAppData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAppActionsForApp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAppActionsForAppQueryKey(options)
    });
};

/**
 * Create an action happening in an app
 * Create an action happening in an app given data and type.
 */
export const createAppActionMutation = (options?: Partial<Options<CreateAppActionData>>): UseMutationOptions<CreateAppActionResponse, CreateAppActionError, Options<CreateAppActionData>> => {
    const mutationOptions: UseMutationOptions<CreateAppActionResponse, CreateAppActionError, Options<CreateAppActionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAppAction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAppSettingsForAppQueryKey = (options: Options<GetAppSettingsForAppData>) => createQueryKey('getAppSettingsForApp', options);

/**
 * Get all settings of an app
 * Get all settings for an app.
 */
export const getAppSettingsForAppOptions = (options: Options<GetAppSettingsForAppData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAppSettingsForApp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAppSettingsForAppQueryKey(options)
    });
};

/**
 * Create a setting for an app
 * Create a setting in an app given data and name. Only admins can create settings.
 */
export const createAppSettingMutation = (options?: Partial<Options<CreateAppSettingData>>): UseMutationOptions<CreateAppSettingResponse, CreateAppSettingError, Options<CreateAppSettingData>> => {
    const mutationOptions: UseMutationOptions<CreateAppSettingResponse, CreateAppSettingError, Options<CreateAppSettingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAppSetting({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete app setting
 * Delete given app setting.
 */
export const deleteAppSettingMutation = (options?: Partial<Options<DeleteAppSettingData>>): UseMutationOptions<DeleteAppSettingResponse, DeleteAppSettingError, Options<DeleteAppSettingData>> => {
    const mutationOptions: UseMutationOptions<DeleteAppSettingResponse, DeleteAppSettingError, Options<DeleteAppSettingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAppSetting({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update app setting
 * Update given app setting with new data. Only admins can update settings.
 */
export const updateAppSettingMutation = (options?: Partial<Options<UpdateAppSettingData>>): UseMutationOptions<UpdateAppSettingResponse, UpdateAppSettingError, Options<UpdateAppSettingData>> => {
    const mutationOptions: UseMutationOptions<UpdateAppSettingResponse, UpdateAppSettingError, Options<UpdateAppSettingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAppSetting({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create app setting file
 * Upload a file to create a corresponding app setting. The setting's name can be defined in the file body (form data) as "name", otherwise it will default to "file"
 */
export const createAppSettingFileMutation = (options?: Partial<Options<CreateAppSettingFileData>>): UseMutationOptions<CreateAppSettingFileResponse, CreateAppSettingFileError, Options<CreateAppSettingFileData>> => {
    const mutationOptions: UseMutationOptions<CreateAppSettingFileResponse, CreateAppSettingFileError, Options<CreateAppSettingFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAppSettingFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadAppSettingFileQueryKey = (options: Options<DownloadAppSettingFileData>) => createQueryKey('downloadAppSettingFile', options);

/**
 * Download app setting file
 * Download app setting file.
 */
export const downloadAppSettingFileOptions = (options: Options<DownloadAppSettingFileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadAppSettingFile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadAppSettingFileQueryKey(options)
    });
};

/**
 * Get a prompt completion from a chatbot
 * Given a prompt, it returns a completion from a chatbot.
 */
export const createChatbotCompletionPromptMutation = (options?: Partial<Options<CreateChatbotCompletionPromptData>>): UseMutationOptions<CreateChatbotCompletionPromptResponse, CreateChatbotCompletionPromptError, Options<CreateChatbotCompletionPromptData>> => {
    const mutationOptions: UseMutationOptions<CreateChatbotCompletionPromptResponse, CreateChatbotCompletionPromptError, Options<CreateChatbotCompletionPromptData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createChatbotCompletionPrompt({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemLoginSchemaTypeQueryKey = (options: Options<GetItemLoginSchemaTypeData>) => createQueryKey('getItemLoginSchemaType', options);

/**
 * Get type of item login
 * Get type of item login. Return null if the item does not allow item login.
 */
export const getItemLoginSchemaTypeOptions = (options: Options<GetItemLoginSchemaTypeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemLoginSchemaType({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemLoginSchemaTypeQueryKey(options)
    });
};

/**
 * Delete item login schema
 * Delete item login data and all related users.
 */
export const deleteItemLoginSchemaMutation = (options?: Partial<Options<DeleteItemLoginSchemaData>>): UseMutationOptions<unknown, DeleteItemLoginSchemaError, Options<DeleteItemLoginSchemaData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteItemLoginSchemaError, Options<DeleteItemLoginSchemaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteItemLoginSchema({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemLoginSchemaQueryKey = (options: Options<GetItemLoginSchemaData>) => createQueryKey('getItemLoginSchema', options);

/**
 * Get item login data
 * Get item login data.
 */
export const getItemLoginSchemaOptions = (options: Options<GetItemLoginSchemaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemLoginSchema({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemLoginSchemaQueryKey(options)
    });
};

/**
 * Update item login data
 * Update item login's status and/or type.
 */
export const updateItemLoginSchemaMutation = (options?: Partial<Options<UpdateItemLoginSchemaData>>): UseMutationOptions<unknown, UpdateItemLoginSchemaError, Options<UpdateItemLoginSchemaData>> => {
    const mutationOptions: UseMutationOptions<unknown, UpdateItemLoginSchemaError, Options<UpdateItemLoginSchemaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItemLoginSchema({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Login or Register in item as guest
 * Log in to an item with necessary credentials depending on item login's type. If the username does not exist, a guest account is created and is given access.
 */
export const loginOrRegisterAsGuestMutation = (options?: Partial<Options<LoginOrRegisterAsGuestData>>): UseMutationOptions<LoginOrRegisterAsGuestResponse, LoginOrRegisterAsGuestError, Options<LoginOrRegisterAsGuestData>> => {
    const mutationOptions: UseMutationOptions<LoginOrRegisterAsGuestResponse, LoginOrRegisterAsGuestError, Options<LoginOrRegisterAsGuestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginOrRegisterAsGuest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOwnBookmarkQueryKey = (options?: Options<GetOwnBookmarkData>) => createQueryKey('getOwnBookmark', options);

/**
 * Get all bookmarked instances of the current member
 * Get all bookmarked instances of the current member
 */
export const getOwnBookmarkOptions = (options?: Options<GetOwnBookmarkData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnBookmark({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnBookmarkQueryKey(options)
    });
};

/**
 * Remove item from bookmarks
 * Remove item from bookmarks
 */
export const deleteBookmarkMutation = (options?: Partial<Options<DeleteBookmarkData>>): UseMutationOptions<DeleteBookmarkResponse, DeleteBookmarkError, Options<DeleteBookmarkData>> => {
    const mutationOptions: UseMutationOptions<DeleteBookmarkResponse, DeleteBookmarkError, Options<DeleteBookmarkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBookmark({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Bookmark item
 * Bookmark item
 */
export const createBookmarkMutation = (options?: Partial<Options<CreateBookmarkData>>): UseMutationOptions<CreateBookmarkResponse, CreateBookmarkError, Options<CreateBookmarkData>> => {
    const mutationOptions: UseMutationOptions<CreateBookmarkResponse, CreateBookmarkError, Options<CreateBookmarkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBookmark({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCollectionsForMemberQueryKey = (options: Options<GetCollectionsForMemberData>) => createQueryKey('getCollectionsForMember', options);

/**
 * Get collections for member
 * Get packed collections for member, used in the builder view of the member.
 */
export const getCollectionsForMemberOptions = (options: Options<GetCollectionsForMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCollectionsForMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCollectionsForMemberQueryKey(options)
    });
};

export const getCollectionInformationsQueryKey = (options: Options<GetCollectionInformationsData>) => createQueryKey('getCollectionInformations', options);

/**
 * Get information of a collection
 * Get information of a collection, including views count.
 */
export const getCollectionInformationsOptions = (options: Options<GetCollectionInformationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCollectionInformations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCollectionInformationsQueryKey(options)
    });
};

/**
 * Publish an item
 * Publish an item. It will become listed in the Library.
 */
export const publishItemMutation = (options?: Partial<Options<PublishItemData>>): UseMutationOptions<PublishItemResponse, PublishItemError, Options<PublishItemData>> => {
    const mutationOptions: UseMutationOptions<PublishItemResponse, PublishItemError, Options<PublishItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await publishItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unpublish an item
 * Unpublish an item. It will stop being available in the Library.
 */
export const unpublishItemMutation = (options?: Partial<Options<UnpublishItemData>>): UseMutationOptions<UnpublishItemResponse, UnpublishItemError, Options<UnpublishItemData>> => {
    const mutationOptions: UseMutationOptions<UnpublishItemResponse, UnpublishItemError, Options<UnpublishItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unpublishItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get collections given search query
 * Get collections given search query. the results are highlighted given the search query.
 */
export const collectionSearchMutation = (options?: Partial<Options<CollectionSearchData>>): UseMutationOptions<CollectionSearchResponse, CollectionSearchError, Options<CollectionSearchData>> => {
    const mutationOptions: UseMutationOptions<CollectionSearchResponse, CollectionSearchError, Options<CollectionSearchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await collectionSearch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get facets for a given facet name
 * Get list of facets and how many collections are tagged with those given a facet name.
 */
export const getFacetsForNameMutation = (options?: Partial<Options<GetFacetsForNameData>>): UseMutationOptions<GetFacetsForNameResponse, GetFacetsForNameError, Options<GetFacetsForNameData>> => {
    const mutationOptions: UseMutationOptions<GetFacetsForNameResponse, GetFacetsForNameError, Options<GetFacetsForNameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await getFacetsForName({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFeaturedCollectionsQueryKey = (options?: Options<GetFeaturedCollectionsData>) => createQueryKey('getFeaturedCollections', options);

/**
 * Get featured collections
 * Get collections that we want to feature on the library home page.
 */
export const getFeaturedCollectionsOptions = (options?: Options<GetFeaturedCollectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeaturedCollections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeaturedCollectionsQueryKey(options)
    });
};

export const getMostLikedCollectionsQueryKey = (options?: Options<GetMostLikedCollectionsData>) => createQueryKey('getMostLikedCollections', options);

/**
 * Get most liked collections
 * Get most liked collections.
 */
export const getMostLikedCollectionsOptions = (options?: Options<GetMostLikedCollectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMostLikedCollections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMostLikedCollectionsQueryKey(options)
    });
};

export const getMostRecentCollectionsQueryKey = (options?: Options<GetMostRecentCollectionsData>) => createQueryKey('getMostRecentCollections', options);

/**
 * Get most recent collections
 * Get most recently published and modified collections
 */
export const getMostRecentCollectionsOptions = (options?: Options<GetMostRecentCollectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMostRecentCollections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMostRecentCollectionsQueryKey(options)
    });
};

export const getApiItemsCollectionsSearchRebuildQueryKey = (options?: Options<GetApiItemsCollectionsSearchRebuildData>) => createQueryKey('getApiItemsCollectionsSearchRebuild', options);

export const getApiItemsCollectionsSearchRebuildOptions = (options?: Options<GetApiItemsCollectionsSearchRebuildData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiItemsCollectionsSearchRebuild({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiItemsCollectionsSearchRebuildQueryKey(options)
    });
};

export const getItemMembershipsForItemQueryKey = (options: Options<GetItemMembershipsForItemData>) => createQueryKey('getItemMembershipsForItem', options);

/**
 * Get memberships for one item
 * Get memberships for one item
 */
export const getItemMembershipsForItemOptions = (options: Options<GetItemMembershipsForItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemMembershipsForItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemMembershipsForItemQueryKey(options)
    });
};

/**
 * Create access to item for account
 * Create access to item for account, given permission
 */
export const createItemMembershipMutation = (options?: Partial<Options<CreateItemMembershipData>>): UseMutationOptions<CreateItemMembershipResponse, CreateItemMembershipError, Options<CreateItemMembershipData>> => {
    const mutationOptions: UseMutationOptions<CreateItemMembershipResponse, CreateItemMembershipError, Options<CreateItemMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItemMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete access to item for account
 * Delete access to item for account
 */
export const deleteItemMembershipMutation = (options?: Partial<Options<DeleteItemMembershipData>>): UseMutationOptions<DeleteItemMembershipResponse, DeleteItemMembershipError, Options<DeleteItemMembershipData>> => {
    const mutationOptions: UseMutationOptions<DeleteItemMembershipResponse, DeleteItemMembershipError, Options<DeleteItemMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteItemMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update permission for item membership
 * Update permission for item membership
 */
export const updateItemMembershipMutation = (options?: Partial<Options<UpdateItemMembershipData>>): UseMutationOptions<UpdateItemMembershipResponse, UpdateItemMembershipError, Options<UpdateItemMembershipData>> => {
    const mutationOptions: UseMutationOptions<UpdateItemMembershipResponse, UpdateItemMembershipError, Options<UpdateItemMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItemMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembershipRequestsByItemIdQueryKey = (options: Options<GetMembershipRequestsByItemIdData>) => createQueryKey('getMembershipRequestsByItemId', options);

/**
 * Get all membership requests for an item
 * Get all membership requests with member information for an item by its ID
 */
export const getMembershipRequestsByItemIdOptions = (options: Options<GetMembershipRequestsByItemIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembershipRequestsByItemId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembershipRequestsByItemIdQueryKey(options)
    });
};

/**
 * Create a membership request
 * Create a membership request for an item with the authenticated member.
 * The member should not have any permission on the item.
 * If there is an Item Login associated with the item, the request will be rejected.
 */
export const createMembershipRequestMutation = (options?: Partial<Options<CreateMembershipRequestData>>): UseMutationOptions<CreateMembershipRequestResponse, DefaultError, Options<CreateMembershipRequestData>> => {
    const mutationOptions: UseMutationOptions<CreateMembershipRequestResponse, DefaultError, Options<CreateMembershipRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createMembershipRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOwnMembershipRequestByItemIdQueryKey = (options: Options<GetOwnMembershipRequestByItemIdData>) => createQueryKey('getOwnMembershipRequestByItemId', options);

/**
 * Get the status of the membership request for the authenticated member
 * Get the status of the membership request for the authenticated member for an item by its ID
 */
export const getOwnMembershipRequestByItemIdOptions = (options: Options<GetOwnMembershipRequestByItemIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnMembershipRequestByItemId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnMembershipRequestByItemIdQueryKey(options)
    });
};

/**
 * Delete a membership request
 * Delete a membership request from a member id and an item id.
 */
export const deleteMembershipRequestMutation = (options?: Partial<Options<DeleteMembershipRequestData>>): UseMutationOptions<DeleteMembershipRequestResponse, DefaultError, Options<DeleteMembershipRequestData>> => {
    const mutationOptions: UseMutationOptions<DeleteMembershipRequestResponse, DefaultError, Options<DeleteMembershipRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMembershipRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create shortcut
 * Create shortcut. If not provided, the name of the shortcut is infered from the actor's language.
 */
export const createShortcutMutation = (options?: Partial<Options<CreateShortcutData>>): UseMutationOptions<CreateShortcutResponse, CreateShortcutError, Options<CreateShortcutData>> => {
    const mutationOptions: UseMutationOptions<CreateShortcutResponse, CreateShortcutError, Options<CreateShortcutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createShortcut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update shortcut
 * Update shortcut given body.
 */
export const updateShortcutMutation = (options?: Partial<Options<UpdateShortcutData>>): UseMutationOptions<UpdateShortcutResponse, UpdateShortcutError, Options<UpdateShortcutData>> => {
    const mutationOptions: UseMutationOptions<UpdateShortcutResponse, UpdateShortcutError, Options<UpdateShortcutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateShortcut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteApiItemsByIdThumbnailsMutation = (options?: Partial<Options<DeleteApiItemsByIdThumbnailsData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteApiItemsByIdThumbnailsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteApiItemsByIdThumbnailsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiItemsByIdThumbnails({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postApiItemsByIdThumbnailsMutation = (options?: Partial<Options<PostApiItemsByIdThumbnailsData>>): UseMutationOptions<PostApiItemsByIdThumbnailsResponse, PostApiItemsByIdThumbnailsError, Options<PostApiItemsByIdThumbnailsData>> => {
    const mutationOptions: UseMutationOptions<PostApiItemsByIdThumbnailsResponse, PostApiItemsByIdThumbnailsError, Options<PostApiItemsByIdThumbnailsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiItemsByIdThumbnails({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadItemThumbnailQueryKey = (options: Options<DownloadItemThumbnailData>) => createQueryKey('downloadItemThumbnail', options);

/**
 * Get an item's thumbnail
 * Get an item's thumbnail at given size. The return value is null if the item did not previously have a thumbnail.
 */
export const downloadItemThumbnailOptions = (options: Options<DownloadItemThumbnailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadItemThumbnail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadItemThumbnailQueryKey(options)
    });
};

/**
 * Upload files
 * Upload files to create corresponding items.
 */
export const uploadFileMutation = (options?: Partial<Options<UploadFileData>>): UseMutationOptions<UploadFileResponse, UploadFileError, Options<UploadFileData>> => {
    const mutationOptions: UseMutationOptions<UploadFileResponse, UploadFileError, Options<UploadFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUrlQueryKey = (options: Options<GetUrlData>) => createQueryKey('getUrl', options);

/**
 * Get file URL
 * Get file URL.
 */
export const getUrlOptions = (options: Options<GetUrlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUrl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUrlQueryKey(options)
    });
};

/**
 * Update file
 * Update file.
 */
export const updateFileMutation = (options?: Partial<Options<UpdateFileData>>): UseMutationOptions<unknown, UpdateFileError, Options<UpdateFileData>> => {
    const mutationOptions: UseMutationOptions<unknown, UpdateFileError, Options<UpdateFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete visibility of item
 * Delete visibility of item with given type.
 */
export const deleteVisibilityMutation = (options?: Partial<Options<DeleteVisibilityData>>): UseMutationOptions<DeleteVisibilityResponse, DeleteVisibilityError, Options<DeleteVisibilityData>> => {
    const mutationOptions: UseMutationOptions<DeleteVisibilityResponse, DeleteVisibilityError, Options<DeleteVisibilityData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteVisibility({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create visibility on item
 * Create visibility on item with given visibility that will apply on itself and its descendants.
 */
export const createVisibilityMutation = (options?: Partial<Options<CreateVisibilityData>>): UseMutationOptions<CreateVisibilityResponse, CreateVisibilityError, Options<CreateVisibilityData>> => {
    const mutationOptions: UseMutationOptions<CreateVisibilityResponse, CreateVisibilityError, Options<CreateVisibilityData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createVisibility({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create folder
 * Create folder.
 */
export const createFolderMutation = (options?: Partial<Options<CreateFolderData>>): UseMutationOptions<CreateFolderResponse, CreateFolderError, Options<CreateFolderData>> => {
    const mutationOptions: UseMutationOptions<CreateFolderResponse, CreateFolderError, Options<CreateFolderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createFolder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update folder
 * Update folder given body.
 */
export const updateFolderMutation = (options?: Partial<Options<UpdateFolderData>>): UseMutationOptions<UpdateFolderResponse, UpdateFolderError, Options<UpdateFolderData>> => {
    const mutationOptions: UseMutationOptions<UpdateFolderResponse, UpdateFolderError, Options<UpdateFolderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFolder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Switch folder item to capsule
 */
export const convertFolderToCapsuleMutation = (options?: Partial<Options<ConvertFolderToCapsuleData>>): UseMutationOptions<ConvertFolderToCapsuleResponse, ConvertFolderToCapsuleError, Options<ConvertFolderToCapsuleData>> => {
    const mutationOptions: UseMutationOptions<ConvertFolderToCapsuleResponse, ConvertFolderToCapsuleError, Options<ConvertFolderToCapsuleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await convertFolderToCapsule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a folder with a thumbnail
 * Create a folder with a thumbnail. The data is sent using a form-data.
 */
export const createFolderWithThumbnailMutation = (options?: Partial<Options<CreateFolderWithThumbnailData>>): UseMutationOptions<CreateFolderWithThumbnailResponse, CreateFolderWithThumbnailError, Options<CreateFolderWithThumbnailData>> => {
    const mutationOptions: UseMutationOptions<CreateFolderWithThumbnailResponse, CreateFolderWithThumbnailError, Options<CreateFolderWithThumbnailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createFolderWithThumbnail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create capsule
 * Create capsule.
 */
export const createCapsuleMutation = (options?: Partial<Options<CreateCapsuleData>>): UseMutationOptions<CreateCapsuleResponse, CreateCapsuleError, Options<CreateCapsuleData>> => {
    const mutationOptions: UseMutationOptions<CreateCapsuleResponse, CreateCapsuleError, Options<CreateCapsuleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCapsule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Switch capsule item to folder
 */
export const convertCapsuleToFolderMutation = (options?: Partial<Options<ConvertCapsuleToFolderData>>): UseMutationOptions<ConvertCapsuleToFolderResponse, ConvertCapsuleToFolderError, Options<ConvertCapsuleToFolderData>> => {
    const mutationOptions: UseMutationOptions<ConvertCapsuleToFolderResponse, ConvertCapsuleToFolderError, Options<ConvertCapsuleToFolderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await convertCapsuleToFolder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create app
 * Create app.
 */
export const createAppMutation = (options?: Partial<Options<CreateAppData>>): UseMutationOptions<CreateAppResponse, CreateAppError, Options<CreateAppData>> => {
    const mutationOptions: UseMutationOptions<CreateAppResponse, CreateAppError, Options<CreateAppData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createApp({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update app
 * Update app given body.
 */
export const updateAppMutation = (options?: Partial<Options<UpdateAppData>>): UseMutationOptions<UpdateAppResponse, UpdateAppError, Options<UpdateAppData>> => {
    const mutationOptions: UseMutationOptions<UpdateAppResponse, UpdateAppError, Options<UpdateAppData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateApp({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete alias
 * Delete short link's alias.
 */
export const deleteAliasMutation = (options?: Partial<Options<DeleteAliasData>>): UseMutationOptions<DeleteAliasResponse, DeleteAliasError, Options<DeleteAliasData>> => {
    const mutationOptions: UseMutationOptions<DeleteAliasResponse, DeleteAliasError, Options<DeleteAliasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAlias({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getShortLinkRedirectionQueryKey = (options: Options<GetShortLinkRedirectionData>) => createQueryKey('getShortLinkRedirection', options);

/**
 * Get redirection for short link
 * Get redirection for given short link.
 */
export const getShortLinkRedirectionOptions = (options: Options<GetShortLinkRedirectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getShortLinkRedirection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getShortLinkRedirectionQueryKey(options)
    });
};

/**
 * Update short link
 * Update the alias of the short link.
 */
export const updateShortLinkMutation = (options?: Partial<Options<UpdateShortLinkData>>): UseMutationOptions<UpdateShortLinkResponse, UpdateShortLinkError, Options<UpdateShortLinkData>> => {
    const mutationOptions: UseMutationOptions<UpdateShortLinkResponse, UpdateShortLinkError, Options<UpdateShortLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateShortLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getShortLinkAvailabilityQueryKey = (options: Options<GetShortLinkAvailabilityData>) => createQueryKey('getShortLinkAvailability', options);

/**
 * Get whether an alias is available
 * Get whether an alias is available.
 */
export const getShortLinkAvailabilityOptions = (options: Options<GetShortLinkAvailabilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getShortLinkAvailability({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getShortLinkAvailabilityQueryKey(options)
    });
};

export const getShortLinksForItemQueryKey = (options: Options<GetShortLinksForItemData>) => createQueryKey('getShortLinksForItem', options);

/**
 * Get all short links for item
 * Get all short links created for an item. The response could be an empty object or a key-value with at least one platform and the alias.
 */
export const getShortLinksForItemOptions = (options: Options<GetShortLinksForItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getShortLinksForItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getShortLinksForItemQueryKey(options)
    });
};

/**
 * Create short link for item
 * Create short link for item.
 */
export const createShortLinkMutation = (options?: Partial<Options<CreateShortLinkData>>): UseMutationOptions<CreateShortLinkResponse, CreateShortLinkError, Options<CreateShortLinkData>> => {
    const mutationOptions: UseMutationOptions<CreateShortLinkResponse, CreateShortLinkError, Options<CreateShortLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createShortLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiItemsPublicationByItemIdStatusQueryKey = (options: Options<GetApiItemsPublicationByItemIdStatusData>) => createQueryKey('getApiItemsPublicationByItemIdStatus', options);

export const getApiItemsPublicationByItemIdStatusOptions = (options: Options<GetApiItemsPublicationByItemIdStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiItemsPublicationByItemIdStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiItemsPublicationByItemIdStatusQueryKey(options)
    });
};

export const getApiItemsH5pAssetsIntegrationHtmlQueryKey = (options?: Options<GetApiItemsH5pAssetsIntegrationHtmlData>) => createQueryKey('getApiItemsH5pAssetsIntegrationHtml', options);

export const getApiItemsH5pAssetsIntegrationHtmlOptions = (options?: Options<GetApiItemsH5pAssetsIntegrationHtmlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiItemsH5pAssetsIntegrationHtml({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiItemsH5pAssetsIntegrationHtmlQueryKey(options)
    });
};

/**
 * Import H5P file
 * Import H5P file and create corresponding item.
 */
export const importH5pMutation = (options?: Partial<Options<ImportH5pData>>): UseMutationOptions<ImportH5pResponse, ImportH5pError, Options<ImportH5pData>> => {
    const mutationOptions: UseMutationOptions<ImportH5pResponse, ImportH5pError, Options<ImportH5pData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await importH5P({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create etherpad
 * Create an etherpad item.
 */
export const createEtherpadMutation = (options?: Partial<Options<CreateEtherpadData>>): UseMutationOptions<CreateEtherpadResponse, CreateEtherpadError, Options<CreateEtherpadData>> => {
    const mutationOptions: UseMutationOptions<CreateEtherpadResponse, CreateEtherpadError, Options<CreateEtherpadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createEtherpad({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update etherpad
 * Update etherpad properties, including permission of readers.
 */
export const updateEtherpadMutation = (options?: Partial<Options<UpdateEtherpadData>>): UseMutationOptions<UpdateEtherpadResponse, UpdateEtherpadError, Options<UpdateEtherpadData>> => {
    const mutationOptions: UseMutationOptions<UpdateEtherpadResponse, UpdateEtherpadError, Options<UpdateEtherpadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateEtherpad({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEtherpadFromItemQueryKey = (options: Options<GetEtherpadFromItemData>) => createQueryKey('getEtherpadFromItem', options);

/**
 * Get etherpad information
 * Get etherpad information from item id
 */
export const getEtherpadFromItemOptions = (options: Options<GetEtherpadFromItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEtherpadFromItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEtherpadFromItemQueryKey(options)
    });
};

/**
 * Import ZIP content
 * Import and extract the content of a ZIP, creating the corresponding structure and items.
 */
export const importZipMutation = (options?: Partial<Options<ImportZipData>>): UseMutationOptions<unknown, ImportZipError, Options<ImportZipData>> => {
    const mutationOptions: UseMutationOptions<unknown, ImportZipError, Options<ImportZipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await importZip({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Download non-folder content
 * Download non-folder content. Return raw file for single item.
 */
export const downloadFileMutation = (options?: Partial<Options<DownloadFileData>>): UseMutationOptions<unknown, DownloadFileError, Options<DownloadFileData>> => {
    const mutationOptions: UseMutationOptions<unknown, DownloadFileError, Options<DownloadFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await downloadFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Export folder content as zip archive
 * Export the folder's content as a ZIP archive. The user will receive an email with a link to download the ZIP archive. Users can download any resource they can access.
 */
export const exportZipMutation = (options?: Partial<Options<ExportZipData>>): UseMutationOptions<unknown, ExportZipError, Options<ExportZipData>> => {
    const mutationOptions: UseMutationOptions<unknown, ExportZipError, Options<ExportZipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exportZip({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Export content
 * Export content. Return raw file for single item, or a ZIP with structure and items for a folder.
 */
export const graaspZipExportMutation = (options?: Partial<Options<GraaspZipExportData>>): UseMutationOptions<unknown, GraaspZipExportError, Options<GraaspZipExportData>> => {
    const mutationOptions: UseMutationOptions<unknown, GraaspZipExportError, Options<GraaspZipExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await graaspZipExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLinkMetadataQueryKey = (options: Options<GetLinkMetadataData>) => createQueryKey('getLinkMetadata', options);

/**
 * Get metadata information from iframely for given url
 * Get metadata information from iframely for given url.
 */
export const getLinkMetadataOptions = (options: Options<GetLinkMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLinkMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLinkMetadataQueryKey(options)
    });
};

/**
 * Create link
 * Create link.
 */
export const createLinkMutation = (options?: Partial<Options<CreateLinkData>>): UseMutationOptions<CreateLinkResponse, CreateLinkError, Options<CreateLinkData>> => {
    const mutationOptions: UseMutationOptions<CreateLinkResponse, CreateLinkError, Options<CreateLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update link
 * Update link given body.
 */
export const updateLinkMutation = (options?: Partial<Options<UpdateLinkData>>): UseMutationOptions<UpdateLinkResponse, UpdateLinkError, Options<UpdateLinkData>> => {
    const mutationOptions: UseMutationOptions<UpdateLinkResponse, UpdateLinkError, Options<UpdateLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create document
 * Create document with given payload. The content will be sanitized.
 */
export const createDocumentMutation = (options?: Partial<Options<CreateDocumentData>>): UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> => {
    const mutationOptions: UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update document
 * Update document given payload. The content will be sanitized.
 */
export const updateDocumentMutation = (options?: Partial<Options<UpdateDocumentData>>): UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> => {
    const mutationOptions: UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInvitationByIdQueryKey = (options: Options<GetInvitationByIdData>) => createQueryKey('getInvitationById', options);

/**
 * Get invitation
 * Get invitation by id
 */
export const getInvitationByIdOptions = (options: Options<GetInvitationByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInvitationById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInvitationByIdQueryKey(options)
    });
};

/**
 * Invite user by email to access an item
 * Invite non-registered user with their email to access given item.
 */
export const createInvitationMutation = (options?: Partial<Options<CreateInvitationData>>): UseMutationOptions<CreateInvitationResponse, CreateInvitationError, Options<CreateInvitationData>> => {
    const mutationOptions: UseMutationOptions<CreateInvitationResponse, CreateInvitationError, Options<CreateInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInvitationForItemQueryKey = (options: Options<GetInvitationForItemData>) => createQueryKey('getInvitationForItem', options);

/**
 * Get invitations for a given item
 * Get invitation for a given item
 */
export const getInvitationForItemOptions = (options: Options<GetInvitationForItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInvitationForItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInvitationForItemQueryKey(options)
    });
};

/**
 * Delete invitation
 * Delete invitation
 */
export const deleteInvitationMutation = (options?: Partial<Options<DeleteInvitationData>>): UseMutationOptions<DeleteInvitationResponse, DeleteInvitationError, Options<DeleteInvitationData>> => {
    const mutationOptions: UseMutationOptions<DeleteInvitationResponse, DeleteInvitationError, Options<DeleteInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update invitation
 * Update invitation's name or permission
 */
export const updateInvitationMutation = (options?: Partial<Options<UpdateInvitationData>>): UseMutationOptions<UpdateInvitationResponse, UpdateInvitationError, Options<UpdateInvitationData>> => {
    const mutationOptions: UseMutationOptions<UpdateInvitationResponse, UpdateInvitationError, Options<UpdateInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send invitation
 * Send invitation
 */
export const sendInvitationMutation = (options?: Partial<Options<SendInvitationData>>): UseMutationOptions<SendInvitationResponse, SendInvitationError, Options<SendInvitationData>> => {
    const mutationOptions: UseMutationOptions<SendInvitationResponse, SendInvitationError, Options<SendInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await sendInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Invite users from CSV file in groups given a template
 * Invite users by groups from CSV. This will create groups of users having access to corresponding resources from a given template.
 */
export const inviteFromCsvWithTemplateMutation = (options?: Partial<Options<InviteFromCsvWithTemplateData>>): UseMutationOptions<InviteFromCsvWithTemplateResponse, InviteFromCsvWithTemplateError, Options<InviteFromCsvWithTemplateData>> => {
    const mutationOptions: UseMutationOptions<InviteFromCsvWithTemplateResponse, InviteFromCsvWithTemplateError, Options<InviteFromCsvWithTemplateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await inviteFromCsvWithTemplate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Invite users from CSV file
 * Invite users from CSV file, given their email, optional name and permission level.
 */
export const inviteFromCsvMutation = (options?: Partial<Options<InviteFromCsvData>>): UseMutationOptions<InviteFromCsvResponse, InviteFromCsvError, Options<InviteFromCsvData>> => {
    const mutationOptions: UseMutationOptions<InviteFromCsvResponse, InviteFromCsvError, Options<InviteFromCsvData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await inviteFromCsv({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create an item membership for the logged in user if there is an Item Login
 * Create an item membership on the item with the given ID for the logged in user.
 * The item needs to be associated with an Item Login.
 */
export const enrollMutation = (options?: Partial<Options<EnrollData>>): UseMutationOptions<EnrollResponse, DefaultError, Options<EnrollData>> => {
    const mutationOptions: UseMutationOptions<EnrollResponse, DefaultError, Options<EnrollData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await enroll({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFlagTypesQueryKey = (options?: Options<GetFlagTypesData>) => createQueryKey('getFlagTypes', options);

/**
 * Get flag types
 * Get available flag types.
 */
export const getFlagTypesOptions = (options?: Options<GetFlagTypesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFlagTypes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFlagTypesQueryKey(options)
    });
};

/**
 * Flag item
 * Flag item with given type.
 */
export const createItemFlagMutation = (options?: Partial<Options<CreateItemFlagData>>): UseMutationOptions<CreateItemFlagResponse, CreateItemFlagError, Options<CreateItemFlagData>> => {
    const mutationOptions: UseMutationOptions<CreateItemFlagResponse, CreateItemFlagError, Options<CreateItemFlagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItemFlag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOwnRecycledItemsQueryKey = (options: Options<GetOwnRecycledItemsData>) => createQueryKey('getOwnRecycledItems', options);

/**
 * Get own recycled items
 * Get own recycled items.
 */
export const getOwnRecycledItemsOptions = (options: Options<GetOwnRecycledItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnRecycledItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnRecycledItemsQueryKey(options)
    });
};

export const getOwnRecycledItemsInfiniteQueryKey = (options: Options<GetOwnRecycledItemsData>): QueryKey<Options<GetOwnRecycledItemsData>> => createQueryKey('getOwnRecycledItems', options, true);

/**
 * Get own recycled items
 * Get own recycled items.
 */
export const getOwnRecycledItemsInfiniteOptions = (options: Options<GetOwnRecycledItemsData>) => {
    return infiniteQueryOptions<GetOwnRecycledItemsResponse, GetOwnRecycledItemsError, InfiniteData<GetOwnRecycledItemsResponse>, QueryKey<Options<GetOwnRecycledItemsData>>, number | Pick<QueryKey<Options<GetOwnRecycledItemsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetOwnRecycledItemsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getOwnRecycledItems({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnRecycledItemsInfiniteQueryKey(options)
    });
};

/**
 * Recycle many items
 * Recycle many items. This will create as many recycled item data.
 */
export const recycleManyItemsMutation = (options?: Partial<Options<RecycleManyItemsData>>): UseMutationOptions<RecycleManyItemsResponse, RecycleManyItemsError, Options<RecycleManyItemsData>> => {
    const mutationOptions: UseMutationOptions<RecycleManyItemsResponse, RecycleManyItemsError, Options<RecycleManyItemsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await recycleManyItems({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore many items
 * Restore many items. This will delete as many recycled item data.
 */
export const restoreManyItemsMutation = (options?: Partial<Options<RestoreManyItemsData>>): UseMutationOptions<RestoreManyItemsResponse, RestoreManyItemsError, Options<RestoreManyItemsData>> => {
    const mutationOptions: UseMutationOptions<RestoreManyItemsResponse, RestoreManyItemsError, Options<RestoreManyItemsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restoreManyItems({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLatestItemValidationGroupQueryKey = (options: Options<GetLatestItemValidationGroupData>) => createQueryKey('getLatestItemValidationGroup', options);

/**
 * Get latest validation information.
 * Get latest validation information. Returns null if no validation has been performed before.
 */
export const getLatestItemValidationGroupOptions = (options: Options<GetLatestItemValidationGroupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestItemValidationGroup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestItemValidationGroupQueryKey(options)
    });
};

/**
 * Validate item
 * Validate item's tree against many processes, such as nudity detection.
 */
export const validateItemMutation = (options?: Partial<Options<ValidateItemData>>): UseMutationOptions<ValidateItemResponse, ValidateItemError, Options<ValidateItemData>> => {
    const mutationOptions: UseMutationOptions<ValidateItemResponse, ValidateItemError, Options<ValidateItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await validateItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLikesForCurrentMemberQueryKey = (options?: Options<GetLikesForCurrentMemberData>) => createQueryKey('getLikesForCurrentMember', options);

/**
 * Get likes for current member
 * Get likes for current member. Item property is a packed item.
 */
export const getLikesForCurrentMemberOptions = (options?: Options<GetLikesForCurrentMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLikesForCurrentMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLikesForCurrentMemberQueryKey(options)
    });
};

export const getLikesForItemQueryKey = (options: Options<GetLikesForItemData>) => createQueryKey('getLikesForItem', options);

/**
 * Get likes for item
 * Get likes for item.
 */
export const getLikesForItemOptions = (options: Options<GetLikesForItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLikesForItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLikesForItemQueryKey(options)
    });
};

/**
 * Unlike item
 * Unlike item.
 */
export const deleteItemLikeMutation = (options?: Partial<Options<DeleteItemLikeData>>): UseMutationOptions<DeleteItemLikeResponse, DeleteItemLikeError, Options<DeleteItemLikeData>> => {
    const mutationOptions: UseMutationOptions<DeleteItemLikeResponse, DeleteItemLikeError, Options<DeleteItemLikeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteItemLike({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Like item
 * Like item.
 */
export const createItemLikeMutation = (options?: Partial<Options<CreateItemLikeData>>): UseMutationOptions<CreateItemLikeResponse, CreateItemLikeError, Options<CreateItemLikeData>> => {
    const mutationOptions: UseMutationOptions<CreateItemLikeResponse, CreateItemLikeError, Options<CreateItemLikeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItemLike({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Clear all mentions for current user
 * Clear all mentions for current user.
 */
export const clearAllMentionsMutation = (options?: Partial<Options<ClearAllMentionsData>>): UseMutationOptions<ClearAllMentionsResponse, ClearAllMentionsError, Options<ClearAllMentionsData>> => {
    const mutationOptions: UseMutationOptions<ClearAllMentionsResponse, ClearAllMentionsError, Options<ClearAllMentionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await clearAllMentions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOwnMentionsQueryKey = (options?: Options<GetOwnMentionsData>) => createQueryKey('getOwnMentions', options);

/**
 * Get mentions for current user
 * Get mentions for current user.
 */
export const getOwnMentionsOptions = (options?: Options<GetOwnMentionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOwnMentions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOwnMentionsQueryKey(options)
    });
};

/**
 * Delete mention
 * Delete mention.
 */
export const deleteMentionMutation = (options?: Partial<Options<DeleteMentionData>>): UseMutationOptions<DeleteMentionResponse, DeleteMentionError, Options<DeleteMentionData>> => {
    const mutationOptions: UseMutationOptions<DeleteMentionResponse, DeleteMentionError, Options<DeleteMentionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMention({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Patch mention
 * Patch mention's status.
 */
export const patchMentionMutation = (options?: Partial<Options<PatchMentionData>>): UseMutationOptions<PatchMentionResponse, PatchMentionError, Options<PatchMentionData>> => {
    const mutationOptions: UseMutationOptions<PatchMentionResponse, PatchMentionError, Options<PatchMentionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMention({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Clear messages of chat
 * Clear messages of chat for given item.
 */
export const clearChatMessageMutation = (options?: Partial<Options<ClearChatMessageData>>): UseMutationOptions<ClearChatMessageResponse, ClearChatMessageError, Options<ClearChatMessageData>> => {
    const mutationOptions: UseMutationOptions<ClearChatMessageResponse, ClearChatMessageError, Options<ClearChatMessageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await clearChatMessage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getChatQueryKey = (options: Options<GetChatData>) => createQueryKey('getChat', options);

/**
 * Get chat
 * Get chat object for given item.
 */
export const getChatOptions = (options: Options<GetChatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChatQueryKey(options)
    });
};

/**
 * Save message in chat
 * Save message in chat for given item.
 */
export const createChatMessageMutation = (options?: Partial<Options<CreateChatMessageData>>): UseMutationOptions<CreateChatMessageResponse, CreateChatMessageError, Options<CreateChatMessageData>> => {
    const mutationOptions: UseMutationOptions<CreateChatMessageResponse, CreateChatMessageError, Options<CreateChatMessageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createChatMessage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete message in chat
 * Delete message in chat for given item.
 */
export const deleteChatMessageMutation = (options?: Partial<Options<DeleteChatMessageData>>): UseMutationOptions<DeleteChatMessageResponse, DeleteChatMessageError, Options<DeleteChatMessageData>> => {
    const mutationOptions: UseMutationOptions<DeleteChatMessageResponse, DeleteChatMessageError, Options<DeleteChatMessageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteChatMessage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit message in chat
 * Edit message in chat for given item.
 */
export const patchChatMessageMutation = (options?: Partial<Options<PatchChatMessageData>>): UseMutationOptions<PatchChatMessageResponse, PatchChatMessageError, Options<PatchChatMessageData>> => {
    const mutationOptions: UseMutationOptions<PatchChatMessageResponse, PatchChatMessageError, Options<PatchChatMessageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchChatMessage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Save action for item
 * Save action for item with given type and extra.
 */
export const postActionMutation = (options?: Partial<Options<PostActionData>>): UseMutationOptions<PostActionResponse, PostActionError, Options<PostActionData>> => {
    const mutationOptions: UseMutationOptions<PostActionResponse, PostActionError, Options<PostActionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send request to export actions
 * Send request to export actions for given item. The user receives an email with a download link. The generated export is available for a week, and can be generated only once a day.
 */
export const exportActionsMutation = (options?: Partial<Options<ExportActionsData>>): UseMutationOptions<ExportActionsResponse, ExportActionsError, Options<ExportActionsData>> => {
    const mutationOptions: UseMutationOptions<ExportActionsResponse, ExportActionsError, Options<ExportActionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exportActions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemActionsByDayQueryKey = (options: Options<GetItemActionsByDayData>) => createQueryKey('getItemActionsByDay', options);

/**
 * Get actions for item and its descendants by day
 * Get sum of actions count per type generated by users for the given item and its descendants by day.
 */
export const getItemActionsByDayOptions = (options: Options<GetItemActionsByDayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemActionsByDay({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemActionsByDayQueryKey(options)
    });
};

export const getItemActionsByHourQueryKey = (options: Options<GetItemActionsByHourData>) => createQueryKey('getItemActionsByHour', options);

/**
 * Get actions for item and its descendants by hour
 * Get sum of actions count per type generated by users for the given item and its descendants by hour.
 */
export const getItemActionsByHourOptions = (options: Options<GetItemActionsByHourData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemActionsByHour({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemActionsByHourQueryKey(options)
    });
};

export const getItemActionsByWeekdayQueryKey = (options: Options<GetItemActionsByWeekdayData>) => createQueryKey('getItemActionsByWeekday', options);

/**
 * Get actions for item and its descendants by weekday
 * Get sum of actions count per type generated by users for the given item and its descendants by weekday.
 */
export const getItemActionsByWeekdayOptions = (options: Options<GetItemActionsByWeekdayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemActionsByWeekday({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemActionsByWeekdayQueryKey(options)
    });
};

/**
 * Remove a geolocation for an item
 * Remove a geolocation for an item.
 */
export const deleteGeolocationMutation = (options?: Partial<Options<DeleteGeolocationData>>): UseMutationOptions<DeleteGeolocationResponse, DeleteGeolocationError, Options<DeleteGeolocationData>> => {
    const mutationOptions: UseMutationOptions<DeleteGeolocationResponse, DeleteGeolocationError, Options<DeleteGeolocationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGeolocation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGeolocationByItemQueryKey = (options: Options<GetGeolocationByItemData>) => createQueryKey('getGeolocationByItem', options);

/**
 * Get the geolocation info of the given item
 * Get the geolocation info of the given item, alongside the complete information about the item.
 */
export const getGeolocationByItemOptions = (options: Options<GetGeolocationByItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGeolocationByItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGeolocationByItemQueryKey(options)
    });
};

/**
 * Set a geolocation on an item
 * Set a geolocation on an item.
 */
export const putGeolocationMutation = (options?: Partial<Options<PutGeolocationData>>): UseMutationOptions<PutGeolocationResponse, PutGeolocationError, Options<PutGeolocationData>> => {
    const mutationOptions: UseMutationOptions<PutGeolocationResponse, PutGeolocationError, Options<PutGeolocationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putGeolocation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemsInBoxQueryKey = (options: Options<GetItemsInBoxData>) => createQueryKey('getItemsInBox', options);

/**
 * Get items within a box defined by geographic coordinates
 * Get accessible items within a box defined by geographic coordinates, within a parent if given.
 */
export const getItemsInBoxOptions = (options: Options<GetItemsInBoxData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemsInBox({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemsInBoxQueryKey(options)
    });
};

export const geolocationReverseQueryKey = (options: Options<GeolocationReverseData>) => createQueryKey('geolocationReverse', options);

/**
 * Get address information of given geographic coordinates
 * Get address information of given geographic coordinates. This endpoint is using a third-party API.
 */
export const geolocationReverseOptions = (options: Options<GeolocationReverseData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await geolocationReverse({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: geolocationReverseQueryKey(options)
    });
};

export const geolocationSearchQueryKey = (options: Options<GeolocationSearchData>) => createQueryKey('geolocationSearch', options);

/**
 * Get geographic information from a string
 * Get geographic information from a string. This endpoint is using a third-party API.
 */
export const geolocationSearchOptions = (options: Options<GeolocationSearchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await geolocationSearch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: geolocationSearchQueryKey(options)
    });
};

export const getTagsForItemQueryKey = (options: Options<GetTagsForItemData>) => createQueryKey('getTagsForItem', options);

/**
 * Get tags for item
 * Get tags for item.
 */
export const getTagsForItemOptions = (options: Options<GetTagsForItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagsForItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagsForItemQueryKey(options)
    });
};

/**
 * Create tag for item
 * Create tag for the item. The tag will be associated with the given item. If the tag does not already exist in the common list of tags, it will be added and other users will see it in their suggestions.
 */
export const createTagForItemMutation = (options?: Partial<Options<CreateTagForItemData>>): UseMutationOptions<CreateTagForItemResponse, CreateTagForItemError, Options<CreateTagForItemData>> => {
    const mutationOptions: UseMutationOptions<CreateTagForItemResponse, CreateTagForItemError, Options<CreateTagForItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTagForItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete tag associated with item
 * Delete tag associated with item. It does not throw if the specified tag is not originally associated with the item.
 */
export const deleteTagForItemMutation = (options?: Partial<Options<DeleteTagForItemData>>): UseMutationOptions<DeleteTagForItemResponse, DeleteTagForItemError, Options<DeleteTagForItemData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagForItemResponse, DeleteTagForItemError, Options<DeleteTagForItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTagForItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create page
 * Create page and its content.
 */
export const createPageMutation = (options?: Partial<Options<CreatePageData>>): UseMutationOptions<CreatePageResponse, CreatePageError, Options<CreatePageData>> => {
    const mutationOptions: UseMutationOptions<CreatePageResponse, CreatePageError, Options<CreatePageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pagesWebsocketsQueryKey = (options: Options<PagesWebsocketsData>) => createQueryKey('pagesWebsockets', options);

/**
 * Connect to websockets for a page
 * Connect to websockets for a page and allow collaboration through yjs.
 */
export const pagesWebsocketsOptions = (options: Options<PagesWebsocketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pagesWebsockets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pagesWebsocketsQueryKey(options)
    });
};

export const pagesWebsockets2QueryKey = (options: Options<PagesWebsockets2Data>) => createQueryKey('pagesWebsockets2', options);

/**
 * Connect to websockets for a page
 * Connect to websockets for a page and allow collaboration through yjs.
 */
export const pagesWebsockets2Options = (options: Options<PagesWebsockets2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pagesWebsockets2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pagesWebsockets2QueryKey(options)
    });
};

/**
 * Delete many items
 * Delete many items given their ids. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const deleteManyItemsMutation = (options?: Partial<Options<DeleteManyItemsData>>): UseMutationOptions<DeleteManyItemsResponse, DeleteManyItemsError, Options<DeleteManyItemsData>> => {
    const mutationOptions: UseMutationOptions<DeleteManyItemsResponse, DeleteManyItemsError, Options<DeleteManyItemsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteManyItems({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create item
 * Create item, whose possible types are folder, app, document, embeddedLink, file, etherpad, h5p and shortcut.
 */
export const createItemMutation = (options?: Partial<Options<CreateItemData>>): UseMutationOptions<CreateItemResponse, CreateItemError, Options<CreateItemData>> => {
    const mutationOptions: UseMutationOptions<CreateItemResponse, CreateItemError, Options<CreateItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemQueryKey = (options: Options<GetItemData>) => createQueryKey('getItem', options);

/**
 * Get item
 * Get item by its id.
 */
export const getItemOptions = (options: Options<GetItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemQueryKey(options)
    });
};

/**
 * Update item
 * Update item given body.
 */
export const updateItemMutation = (options?: Partial<Options<UpdateItemData>>): UseMutationOptions<UpdateItemResponse, UpdateItemError, Options<UpdateItemData>> => {
    const mutationOptions: UseMutationOptions<UpdateItemResponse, UpdateItemError, Options<UpdateItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAccessibleItemsQueryKey = (options: Options<GetAccessibleItemsData>) => createQueryKey('getAccessibleItems', options);

/**
 * Get accessible items
 * Get items the user has access to
 */
export const getAccessibleItemsOptions = (options: Options<GetAccessibleItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAccessibleItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAccessibleItemsQueryKey(options)
    });
};

export const getAccessibleItemsInfiniteQueryKey = (options: Options<GetAccessibleItemsData>): QueryKey<Options<GetAccessibleItemsData>> => createQueryKey('getAccessibleItems', options, true);

/**
 * Get accessible items
 * Get items the user has access to
 */
export const getAccessibleItemsInfiniteOptions = (options: Options<GetAccessibleItemsData>) => {
    return infiniteQueryOptions<GetAccessibleItemsResponse, GetAccessibleItemsError, InfiniteData<GetAccessibleItemsResponse>, QueryKey<Options<GetAccessibleItemsData>>, number | Pick<QueryKey<Options<GetAccessibleItemsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAccessibleItemsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAccessibleItems({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAccessibleItemsInfiniteQueryKey(options)
    });
};

export const getChildrenQueryKey = (options: Options<GetChildrenData>) => createQueryKey('getChildren', options);

/**
 * Get children of item
 * Get children of item given its id.
 */
export const getChildrenOptions = (options: Options<GetChildrenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChildren({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChildrenQueryKey(options)
    });
};

export const getDescendantItemsQueryKey = (options: Options<GetDescendantItemsData>) => createQueryKey('getDescendantItems', options);

/**
 * Get descendant items of item
 * Get descendant items of item given its id.
 */
export const getDescendantItemsOptions = (options: Options<GetDescendantItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDescendantItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDescendantItemsQueryKey(options)
    });
};

export const getParentItemsQueryKey = (options: Options<GetParentItemsData>) => createQueryKey('getParentItems', options);

/**
 * Get parents of item
 * Get parent items of item given its id.
 */
export const getParentItemsOptions = (options: Options<GetParentItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParentItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getParentItemsQueryKey(options)
    });
};

/**
 * Reorder item
 * Reorder item within its parent given previous item id.
 */
export const reorderItemMutation = (options?: Partial<Options<ReorderItemData>>): UseMutationOptions<ReorderItemResponse, ReorderItemError, Options<ReorderItemData>> => {
    const mutationOptions: UseMutationOptions<ReorderItemResponse, ReorderItemError, Options<ReorderItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reorderItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Move many items
 * Move many items given their ids to a parent target. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const moveManyItemsMutation = (options?: Partial<Options<MoveManyItemsData>>): UseMutationOptions<MoveManyItemsResponse, MoveManyItemsError, Options<MoveManyItemsData>> => {
    const mutationOptions: UseMutationOptions<MoveManyItemsResponse, MoveManyItemsError, Options<MoveManyItemsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await moveManyItems({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Copy many items
 * Copy many items given their ids in a parent target. This endpoint is asynchronous and a feedback is returned through websockets.
 */
export const copyManyItemsMutation = (options?: Partial<Options<CopyManyItemsData>>): UseMutationOptions<CopyManyItemsResponse, CopyManyItemsError, Options<CopyManyItemsData>> => {
    const mutationOptions: UseMutationOptions<CopyManyItemsResponse, CopyManyItemsError, Options<CopyManyItemsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await copyManyItems({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create an item with a thumbnail
 * Create an item with a thumbnail. The data is sent using a form-data.
 */
export const createItemWithThumbnailMutation = (options?: Partial<Options<CreateItemWithThumbnailData>>): UseMutationOptions<CreateItemWithThumbnailResponse, CreateItemWithThumbnailError, Options<CreateItemWithThumbnailData>> => {
    const mutationOptions: UseMutationOptions<CreateItemWithThumbnailResponse, CreateItemWithThumbnailError, Options<CreateItemWithThumbnailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItemWithThumbnail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCountForTagsQueryKey = (options: Options<GetCountForTagsData>) => createQueryKey('getCountForTags', options);

/**
 * Get count for tags
 * Get how many times a tag is associated with items, filtered by string search. It can be filtered by category. Get maximum the 10 most used tags.
 */
export const getCountForTagsOptions = (options: Options<GetCountForTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCountForTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCountForTagsQueryKey(options)
    });
};

export const getNextMaintenanceQueryKey = (options?: Options<GetNextMaintenanceData>) => createQueryKey('getNextMaintenance', options);

/**
 * get next maintenance period
 * Return next maintenance period, usually to perform a migration
 */
export const getNextMaintenanceOptions = (options?: Options<GetNextMaintenanceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNextMaintenance({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNextMaintenanceQueryKey(options)
    });
};
